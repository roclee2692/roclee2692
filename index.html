<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AC Automaton Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <style>
    svg { border: 1px solid #ccc; width:100%; height:400px; }
    .node circle { transition: fill 0.2s; }
    .edge.trie { stroke:black; }
    .edge.fail { stroke:red; stroke-dasharray:4 4; fill:none; }
    .edge.default { stroke:gray; stroke-dasharray:2 2; opacity:0.5; }
    .edge.goto { stroke:blue; stroke-width:2; }
  </style>
</head>
<body class="p-4">
  <div id="root"></div>
  <script type="text/babel">
    const {useState, useEffect, useRef} = React;

    class ACNode {
      constructor(id, parent=null, via='') {
        this.id=id; this.parent=parent; this.via=via;
        this.children={}; this.fail=null; this.output=[];
        this.depth=parent?parent.depth+1:0;
        this.pos={x:0,y:0};
      }
    }

    function recordStep(steps, step) {
      steps.push({...step});
    }

    function buildTrieAndRecord(patterns, opts, steps, nodes) {
      const root = nodes[0];
      for(const p of patterns){
        let node=root;
        for(const ch of p){
          let cleanCh = opts.caseSensitive?ch:ch.toLowerCase();
          if(!node.children[cleanCh]){
            const newNode = new ACNode(nodes.length,node,cleanCh);
            node.children[cleanCh]=newNode;
            nodes.push(newNode);
            recordStep(steps,{phase:'insert',title:`Create node ${newNode.id}`,desc:`Create node via '${cleanCh}'`,highlights:{nodes:[node.id,newNode.id],edges:[{from:node.id,to:newNode.id,type:'trie',ch:cleanCh}]},});
          }
          node=node.children[cleanCh];
          recordStep(steps,{phase:'insert',title:`Traverse '${cleanCh}'`,desc:`Move to node ${node.id}`,highlights:{nodes:[node.id],edges:[{from:node.parent.id,to:node.id,type:'trie',ch:cleanCh}]},});
        }
        node.output.push(p);
        recordStep(steps,{phase:'insert',title:`Mark output`,desc:`Node ${node.id} emits [${node.output.join(', ')}]`,highlights:{nodes:[node.id]}});
      }
      if(nodes.length>200){
        alert('Node count > 200, may be slow');
      }
    }

    function buildFailAndRecord(opts, steps, nodes){
      const root=nodes[0];
      root.fail=root;
      const queue=[];
      for(const ch in root.children){
        const child=root.children[ch];
        child.fail=root;
        queue.push(child);
        recordStep(steps,{phase:'fail',title:`Set fail of ${child.id}`,desc:`First layer fail to root`,highlights:{nodes:[child.id,root.id],edges:[{from:child.id,to:root.id,type:'fail'}]}});
      }
      while(queue.length){
        const node=queue.shift();
        for(const ch in node.children){
          const child=node.children[ch];
          queue.push(child);
          let f=node.fail;
          recordStep(steps,{phase:'fail',title:`Find fail for ${child.id}`,desc:`From fail(${node.id}) via '${ch}'`,highlights:{nodes:[node.id],edges:[{from:node.id,to:child.id,type:'trie',ch}]},cursor:{node:node.id}});
          while(f && !f.children[ch]){
            recordStep(steps,{phase:'fail',title:`Fallback`,desc:`Fail from ${f.id} on '${ch}'`,highlights:{nodes:[f.id]},edges:[{from:f.id,to:f.fail?f.fail.id:0,type:'fail'}]});
            if(f===root) break;
            f=f.fail;
          }
          if(f && f.children[ch]) f=f.children[ch];
          else f=root;
          child.fail=f;
          child.output=child.output.concat(f.output);
          recordStep(steps,{phase:'fail',title:`Set fail of ${child.id}`,desc:`Fail to ${f.id}`,highlights:{nodes:[child.id,f.id],edges:[{from:child.id,to:f.id,type:'fail'}]}});
        }
        if(opts.showDefaultTransitions){
          for(const a of opts.alphabet){
            if(!node.children[a]){
              let f=node.fail;
              while(f && !f.children[a]){ if(f===root) break; f=f.fail; }
              const target = f && f.children[a]?f.children[a]:root;
              recordStep(steps,{phase:'fail',title:`Default goto '${a}'`,desc:`From ${node.id} default to ${target.id}`,highlights:{nodes:[node.id,target.id],edges:[{from:node.id,to:target.id,type:'default',ch:a}]}});
            }
          }
        }
      }
    }

    function matchAndRecord(text, opts, steps, nodes){
      const root=nodes[0];
      let node=root;
      for(let i=0;i<text.length;i++){
        const rawCh=text[i];
        const ch=opts.caseSensitive?rawCh:rawCh.toLowerCase();
        recordStep(steps,{phase:'match',title:`Read '${ch}'`,desc:`Processing character '${ch}'`,cursor:{i,ch,node:node.id}});
        while(node && !node.children[ch]){
          recordStep(steps,{phase:'match',title:`Fail fallback`,desc:`No edge '${ch}' from ${node.id}`,highlights:{nodes:[node.id]},edges:[],cursor:{i,ch,node:node.id}});
          if(node===root) break;
          node=node.fail;
        }
        if(node.children[ch]){
          const to=node.children[ch];
          recordStep(steps,{phase:'match',title:`Goto`,desc:`Goto on '${ch}'`,highlights:{nodes:[node.id,to.id],edges:[{from:node.id,to:to.id,type:'goto',ch}]},cursor:{i,ch,node:node.id}});
          node=to;
        }else{
          recordStep(steps,{phase:'match',title:`Stay at root`,desc:`No transition, stay at root`,highlights:{nodes:[root.id]},cursor:{i,ch,node:root.id}});
          node=root;
        }
        if(node.output.length){
          const matches=node.output.map(p=>({index:i-p.length+1,pattern:p,node:node.id}));
          recordStep(steps,{phase:'match',title:`Emit matches`,desc:`Node ${node.id} outputs ${node.output.join(', ')}`,highlights:{nodes:[node.id]},cursor:{i,ch,node:node.id},matches});
        }
      }
    }

    function layout(nodes){
      const layers=[];
      nodes.forEach(n=>{
        if(!layers[n.depth]) layers[n.depth]=[];
        layers[n.depth].push(n);
      });
      const gapX=120,gapY=80;
      layers.forEach((layer,depth)=>{
        const startY=-(layer.length-1)*gapY/2;
        layer.forEach((node,i)=>{
          node.pos={x:depth*gapX,y:startY+i*gapY};
        });
      });
    }

    function drawSteps(step, nodes){
      const highlights=step?.highlights||{};
      const nodeHighlight=new Set(highlights.nodes||[]);
      const edgeHighlight=(highlights.edges||[]);
      return {nodeHighlight,edgeHighlight};
    }

    function saveJSON(data){
      const blob=new Blob([JSON.stringify(data)],{type:'application/json'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='ac_steps.json';
      a.click();
    }

    function App(){
      const [patterns,setPatterns]=useState('he she his hers');
      const [text,setText]=useState('ushers');
      const [alphabet,setAlphabet]=useState('abcdefghijklmnopqrstuvwxyz');
      const [caseSensitive,setCase]=useState(false);
      const [showDefault,setShowDefault]=useState(true);
      const [steps,setSteps]=useState([]);
      const [current,setCurrent]=useState(0);
      const [nodes,setNodes]=useState([new ACNode(0)]);
      const [playing,setPlaying]=useState(false);
      const [speed,setSpeed]=useState(1);
      const timer=useRef(null);
      const svgRef=useRef(null);
      const view=useRef({x:0,y:0,scale:1});
      const [cursor,setCursor]=useState({});
      const [matches,setMatches]=useState([]);

      const presets={
        A:{patterns:'he she his hers',text:'ushers'},
        B:{patterns:'a ab bab bc bca c caa',text:'abccab'},
        C:{patterns:'aba baba aab',text:'babaabaa'}
      };

      function loadPreset(key){
        const p=presets[key];
        if(p){setPatterns(p.patterns); setText(p.text);} }

      function build(){
        const pats=patterns.split(/\s+/).map(p=>p.trim()).filter(p=>p.length>0).map(p=>{
          if(!caseSensitive) return p.toLowerCase();
          return p;
        });
        const opts={alphabet:alphabet.split(''),caseSensitive,showDefaultTransitions:showDefault};
        const nodes=[new ACNode(0)];
        const steps=[];
        buildTrieAndRecord(pats,opts,steps,nodes);
        buildFailAndRecord(opts,steps,nodes);
        matchAndRecord(caseSensitive?text:text.toLowerCase(),opts,steps,nodes);
        layout(nodes);
        setNodes(nodes); setSteps(steps); setCurrent(0); setCursor({}); setMatches([]);
        stop();
      }

      function prev(){ stop(); setCurrent(c=>Math.max(0,c-1)); }
      function next(){ stop(); setCurrent(c=>Math.min(steps.length-1,c+1)); }
      function play(){ setPlaying(p=>!p); }
      function stop(){ setPlaying(false); if(timer.current) clearInterval(timer.current); timer.current=null; }
      useEffect(()=>{
        if(playing){
          timer.current=setInterval(()=>{setCurrent(c=>{if(c>=steps.length-1){stop();return c;} return c+1;});},1000/ speed);
        }else if(timer.current){ clearInterval(timer.current); }
      },[playing,speed,steps]);

      useEffect(()=>{
        const step=steps[current];
        if(step){ setCursor(step.cursor||{}); setMatches(step.matches||[]); }
      },[current,steps]);

      useEffect(()=>{
        const svg=svgRef.current;
        if(!svg) return;
        let dragging=false,last={x:0,y:0};
        function onwheel(e){e.preventDefault(); const scale=Math.exp(e.deltaY*-0.001); view.current.scale*=scale; svg.setAttribute('transform',`translate(${view.current.x},${view.current.y}) scale(${view.current.scale})`);}
        function onmousedown(e){dragging=true;last={x:e.clientX,y:e.clientY};}
        function onmousemove(e){if(dragging){view.current.x+=e.clientX-last.x;view.current.y+=e.clientY-last.y;last={x:e.clientX,y:e.clientY};svg.setAttribute('transform',`translate(${view.current.x},${view.current.y}) scale(${view.current.scale})`);}}
        function onmouseup(){dragging=false;}
        svg.addEventListener('wheel',onwheel);
        svg.addEventListener('mousedown',onmousedown);
        window.addEventListener('mousemove',onmousemove);
        window.addEventListener('mouseup',onmouseup);
        return ()=>{svg.removeEventListener('wheel',onwheel);svg.removeEventListener('mousedown',onmousedown);window.removeEventListener('mousemove',onmousemove);window.removeEventListener('mouseup',onmouseup);};
      },[]);

      const {nodeHighlight,edgeHighlight}=drawSteps(steps[current],nodes);
      function exportJSON(){ saveJSON({steps,patterns,text,opts:{alphabet,caseSensitive,showDefaultTransitions:showDefault}}); }
      function importJSON(e){
        const file=e.target.files[0];
        if(!file) return;
        const reader=new FileReader();
        reader.onload=ev=>{
          const data=JSON.parse(ev.target.result);
          setSteps(data.steps||[]); setPatterns(data.patterns||''); setText(data.text||''); const o=data.opts||{}; setAlphabet(o.alphabet||alphabet); setCase(o.caseSensitive||false); setShowDefault(o.showDefaultTransitions||false); setCurrent(0); stop();
        };
        reader.readAsText(file);
      }

      const infoStep=steps[current]||{};
      return (
        <div className="space-y-4">
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <label className="block">Patterns<input className="border w-full" value={patterns} onChange={e=>setPatterns(e.target.value)} /></label>
              <label className="block">Text<input className="border w-full" value={text} onChange={e=>setText(e.target.value)} /></label>
              <label className="block">Alphabet<input className="border w-full" value={alphabet} onChange={e=>setAlphabet(e.target.value)} /></label>
              <label className="inline-flex items-center mr-4"><input type="checkbox" checked={caseSensitive} onChange={e=>setCase(e.target.checked)} /> <span className="ml-2">Case sensitive</span></label>
              <label className="inline-flex items-center"><input type="checkbox" checked={showDefault} onChange={e=>setShowDefault(e.target.checked)} /> <span className="ml-2">Show default transitions</span></label>
              <div className="mt-2 flex space-x-2 items-center">
                <button className="px-2 py-1 bg-blue-500 text-white" onClick={build}>Build</button>
                <select className="border" onChange={e=>loadPreset(e.target.value)}>
                  <option value="">Preset</option>
                  <option value="A">A</option>
                  <option value="B">B</option>
                  <option value="C">C</option>
                </select>
              </div>
            </div>
            <div>
              <div className="flex items-center space-x-2">
                <button className="px-2 py-1 bg-gray-200" onClick={prev}>Prev</button>
                <button className="px-2 py-1 bg-gray-200" onClick={play}>{playing?'Pause':'Play'}</button>
                <button className="px-2 py-1 bg-gray-200" onClick={next}>Next</button>
                <label className="flex items-center ml-2">Speed<input type="range" min="0.25" max="6" step="0.25" value={speed} onChange={e=>setSpeed(parseFloat(e.target.value))} className="ml-2"/></label>
                <button className="px-2 py-1 bg-green-500 text-white" onClick={exportJSON}>Export</button>
                <label className="px-2 py-1 bg-green-500 text-white cursor-pointer">Import<input type="file" className="hidden" onChange={importJSON}/></label>
              </div>
              <div className="mt-2 text-sm">Step {current+1}/{steps.length} {infoStep.title}</div>
              <div className="text-sm">{infoStep.desc}</div>
              <div className="text-sm">Cursor: {cursor.i!==undefined?`i=${cursor.i}, ch=${cursor.ch}, node=${cursor.node}`:'-'}</div>
              <div className="text-sm">Matches: {matches.map(m=>`${m.pattern}@${m.index}`).join(', ')}</div>
            </div>
          </div>
          <svg className="border" width="800" height="400">
            <g ref={svgRef} transform="translate(0,0) scale(1)">
            {nodes.flatMap(n=>{
              const elems=[];
              for(const ch in n.children){
                const child=n.children[ch];
                const highlighted=edgeHighlight.some(e=>e.from===n.id&&e.to===child.id&&e.type==='goto');
                elems.push(<line key={`e-${n.id}-${child.id}`} x1={n.pos.x} y1={n.pos.y} x2={child.pos.x} y2={child.pos.y} className={`edge trie ${highlighted?'goto':''}`} />);
              }
              if(n.fail && n.fail!==n){
                const highlighted=edgeHighlight.some(e=>e.from===n.id&&e.to===n.fail.id&&e.type==='fail');
                elems.push(<path key={`f-${n.id}`} d={`M${n.pos.x} ${n.pos.y} Q ${(n.pos.x+n.fail.pos.x)/2} ${(n.pos.y+n.fail.pos.y)/2-30} ${n.fail.pos.x} ${n.fail.pos.y}`} className={`edge fail ${highlighted?'goto':''}`} />);
              }
              return elems;
            })}
            {edgeHighlight.filter(e=>e.type==='default').map((e,i)=>{
              const from=nodes[e.from]; const to=nodes[e.to];
              return <line key={`d-${i}`} x1={from.pos.x} y1={from.pos.y} x2={to.pos.x} y2={to.pos.y} className="edge default" />;
            })}
            {nodes.map(n=>(<g key={n.id} className="node" transform={`translate(${n.pos.x},${n.pos.y})`}>
              <circle r={15} fill={nodeHighlight.has(n.id)?'#fef3c7':'white'} stroke={n.output.length?'orange':'black'} strokeWidth={n.output.length?3:1}/>
              <text textAnchor="middle" dy="5" className="text-xs">{n.id}</text>
            </g>))}
            </g>
          </svg>
        </div>
      );
    }

    ReactDOM.render(<App/>,document.getElementById('root'));
  </script>
</body>
</html>
