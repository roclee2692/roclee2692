<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>AC Automaton Simulator</title>
<style>
 body { font-family: Arial, sans-serif; margin: 20px; }
 #controls { margin-bottom: 10px; }
 textarea { width: 100%; height: 80px; }
 #log { height: 150px; overflow: auto; border: 1px solid #ccc; padding: 5px; }
 #automaton { white-space: pre; border: 1px solid #ccc; padding: 5px; margin-top: 10px; }
</style>
</head>
<body>
<h1>Aho-Corasick Automaton Simulator</h1>
<div id="controls">
 <label>Patterns (comma separated):<br/>
  <input id="patterns" type="text" value="he, she, hers, his" style="width:100%" />
 </label><br/>
 <label>Text:<br/>
  <input id="text" type="text" value="ushers" style="width:100%" />
 </label><br/>
 <label>Speed (ms per step): <input id="speed" type="number" value="500" min="50" step="50" /></label>
 <button id="build">Build Automaton</button>
 <button id="start">Start</button>
 <button id="step">Step</button>
 <button id="reset">Reset</button>
</div>
<div id="log"></div>
<h3>Automaton Structure</h3>
<pre id="automaton"></pre>

<script>
// Simple implementation of Aho-Corasick automaton for demonstration
class Node {
  constructor() {
    this.next = {}; // transitions
    this.fail = null; // failure link
    this.output = []; // matched patterns
  }
}

class ACAutomaton {
  constructor() {
    this.root = new Node();
    this.state = this.root;
  }

  addPattern(pattern) {
    let node = this.root;
    for (const ch of pattern) {
      if (!node.next[ch]) node.next[ch] = new Node();
      node = node.next[ch];
    }
    node.output.push(pattern);
  }

  build() {
    const queue = [];
    for (const ch in this.root.next) {
      const child = this.root.next[ch];
      child.fail = this.root;
      queue.push(child);
    }
    while (queue.length) {
      const current = queue.shift();
      for (const ch in current.next) {
        let fail = current.fail;
        while (fail && !fail.next[ch]) fail = fail.fail;
        current.next[ch].fail = fail ? fail.next[ch] : this.root;
        current.next[ch].output = current.next[ch].output.concat(current.next[ch].fail.output);
        queue.push(current.next[ch]);
      }
    }
    this.reset();
  }

  reset() {
    this.state = this.root;
  }

  step(char) {
    let state = this.state;
    while (state && !state.next[char]) state = state.fail;
    this.state = state ? state.next[char] : this.root;
    return this.state.output;
  }

  dump() {
    // Generate a simple text representation of the automaton
    const lines = [];
    let id = 0;
    const map = new Map();
    const queue = [{ node: this.root, id }];
    map.set(this.root, id);
    while (queue.length) {
      const { node, id } = queue.shift();
      const trans = Object.keys(node.next).map(ch => {
        let child = node.next[ch];
        if (!map.has(child)) { map.set(child, ++id); queue.push({ node: child, id }); }
        return `${ch} -> ${map.get(child)}`;
      }).join(', ');
      const fail = node.fail ? map.get(node.fail) : 'null';
      lines.push(`${map.get(node)}: [${trans}] fail:${fail} output:${node.output.join('|')}`);
    }
    return lines.join('\n');
  }
}

const patternsInput = document.getElementById('patterns');
const textInput = document.getElementById('text');
const logDiv = document.getElementById('log');
const automatonPre = document.getElementById('automaton');
const speedInput = document.getElementById('speed');

let automaton = new ACAutomaton();
let interval = null;
let index = 0;

function log(msg) {
  logDiv.textContent += msg + '\n';
  logDiv.scrollTop = logDiv.scrollHeight;
}

function build() {
  automaton = new ACAutomaton();
  const patterns = patternsInput.value.split(',').map(p => p.trim()).filter(Boolean);
  for (const p of patterns) automaton.addPattern(p);
  automaton.build();
  automatonPre.textContent = automaton.dump();
  log('Automaton built.');
  index = 0;
}

function step() {
  const text = textInput.value;
  if (index >= text.length) { log('End of text.'); stop(); return; }
  const ch = text[index++];
  const outputs = automaton.step(ch);
  log(`Read '${ch}', state outputs: ${outputs.join(', ')}`);
}

function start() {
  stop();
  interval = setInterval(() => {
    if (index >= textInput.value.length) { stop(); return; }
    step();
  }, parseInt(speedInput.value));
}

function stop() {
  if (interval) clearInterval(interval);
  interval = null;
}

function reset() {
  stop();
  automaton.reset();
  index = 0;
  log('Reset to start.');
}

document.getElementById('build').onclick = build;
document.getElementById('start').onclick = start;
document.getElementById('step').onclick = step;
document.getElementById('reset').onclick = reset;

build(); // build default on load
</script>
</body>
</html>
